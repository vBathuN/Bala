<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
	<meta content="utf-8" http-equiv="encoding" />
	<meta name="copyright" content="&copy; 2020 Steve Seguin" />
	<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon" />
	<!-- Primary Meta Tags -->
	<title>CAPTION.rtcs.live - translate</title>
	<meta name="title" content="CAPTION.rtcs.live" />
	<meta name="description" content="This is a free-to-use captioning tool Speech-to-text is done using Machine Learning" />
	<meta name="author" content="Steve Seguin" />

	
	<style>
		@font-face {
		  font-family: 'Cousine';
		  src: url('fonts/Cousine-Bold.ttf') format('truetype');
		}
	
		body {
			margin:15px;
			padding:15px;
			height:100%;
			border: 0;
			display: block;
			
			bottom:0;
			overflow:hidden;
			
			font-family: Cousine, monospace;
			
		}

		.output {
			margin:0;
			background-color: #0000;
			color: black;
			font-size: 3.2em;
			line-height: 1.1em;
			letter-spacing: 0.0em;
			
			padding: 0em;
			text-shadow: 0.05em 0.05em 0px rgba(255,255,255,1);
		}
		
		.output span { 
			background-color: black; 
			padding: 8px 8px 0px 8px;
			margin:0;
		}
		
		a {
			color:blue;
			font-size:1.2em;
			text-transform: none;
		}
		
		.github {
			background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAd5JREFUOE+d1MurjlEUBvDfIZQZShEGmMhQiZGZlAlyK4eEAZHcyiVRyq1cUq5FwsD1MJGJiT/AzEzRcR8xMnGOW89pv9q9fScfe/J977o8e61nP2v16HzGYBWWYA4mlbBPeI5HuI9v7fSeDnircRqTh7msMX/ALtyr42rAEbiAzX8BaruTsx0/46gBL/0HWAMe0G01YNq8Xbz5PYuN2ISvCHc5oWEsruA69mJF8a0Mr6kwD/C64mw3zpSgCfjc6nE8vhRbAE+U/+8xI4DrcKNKOol9XfJ4CimgOb0BfIilxfIds/GyS8BZeIGRJf5BAN9gWjE8xcIuwZqwZ1hQPvoDOIBRxRCiN/wj4C30lpyBNmAmYNk/Aj7G4pIz2G75I6Y2Iu0CONwlZ2Ldcl+rqmjvWhdgCdmCi1Xs0KOsxc3C5WDhcw8uI9+dzugyVZFNw3/i1jTCfoVIJmo/VDiJeJ9gPX4U1CRHs4swrnXTO8xsZjlAd9GP+WU1zcPxckGde7WMZbvy5eirl8N5bMUxHMSvYdo9igMt3znsiK29vuLI1ojYU+2dwmWdnwv3V4YskozfUAGdFmzaz4KdgiM43KomNGTW32JnGd0/IZ0A48wrhpPMdFZ+feZievjqpILf7lRg3csIRqAAAAAASUVORK5CYII=");
			background-color: #FFF !important;
			width: 4px;
			height: 12px;
			background-repeat: no-repeat;
			display: inline-block;
			top: 2px;
			position: relative;
			left: 2px;
			filter: invert(100%);
			-webkit-filter: invert(100%);
		}
		div {
			display:block;
			
		}
		textarea {
			display:block;
			width: 300px;
			hight: 300px;
		}
	</style>
</head>
<body>

	<h3>This is a free-to-use captioning, transcription, and translation tool.</h3>
	The overlay-friendly output of the text is mirrored here: <a id="shareLink" href="overlay.html" target='_blank'>*ERROR GENERATING LINK*</a>.
	<br /><br />
	<label>
	  From
	  <select id="lang-from" title="Set input language via the URL `&lang=en-US` option" name="from" class="lang-select"></select>
	</label>
	
	 <label>
	  To
	  <select id="lang-to" name="to" class="lang-select"></select>
	</label>
	
	 <label>
	 Translate with added context?
	 <input type="checkbox" id="fullContext" />
	 </label>
	 <br /><br />
	<div class="footer" id="status"></div>
	<textarea id="input" name="input"></textarea>
	<br />
	<div id="output" class="output"></div>
	
<script>
	
	
(function (w) {
	w.URLSearchParams = w.URLSearchParams || function (searchString) {
		var self = this;
		self.searchString = searchString;
		self.get = function (name) {
			var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(self.searchString);
			if (results == null) {
				return null;
			}
			else {
				return decodeURI(results[1]) || 0;
			}
		};
	};

})(window);
var urlParams = new URLSearchParams(window.location.search);
	
	
let worker;
let modelRegistry;
let version;

const status = function(message){document.getElementById("status").innerText = message;}


const langs = { // https://github.com/mozilla/translate - MPL 2.0 - Mozilla
    "bg": "Bulgarian",
    "cs": "Czech",
    "nl": "Dutch",
    "en": "English",
    "et": "Estonian",
    "de": "German",
    "fr": "French",
    "is": "Icelandic",
    "it": "Italian",
    "nb": "Norwegian BokmÃ¥l",
    "nn": "Norwegian Nynorsk",
    "fa": "Persian",
    "pl": "Polish",
    "pt": "Portuguese",
    "ru": "Russian",
    "es": "Spanish",
    "uk": "Ukrainian"
};


var myLang = navigator.language || "en-US";
if (urlParams.has("lang")){
	myLang = urlParams.get("lang");
} else {
	updateURL("lang="+myLang);
}
var myLangCode = myLang.split("-")[0].toLowerCase();

var targetCode = "de";
if (myLangCode == "de"){
	targetCode = "en";
}

if (urlParams.has("translate") || urlParams.has("target")){
	targetCode = urlParams.get("translate") || urlParams.get("target") || targetCode;
	targetCode = targetCode.split("-")[0].toLowerCase();
} else {
	updateURL("translate="+targetCode);
}

console.log("Language: "+myLang);


const langFrom = document.getElementById("lang-from");
const langTo = document.getElementById("lang-to");

let supportedFromCodes = {};
let supportedToCodes = {};
let currentTo = null;

if (window.Worker) {
    worker = new Worker("worker.js");
    worker.postMessage(["import"]);
}

const translateCall = (text) => {
    if (!text.trim().length) return;
    const paragraphs = text.split("\n");
    const lngFrom = langFrom.value;
    const lngTo = langTo.value;
    worker.postMessage(["translate", lngFrom, lngTo, paragraphs, null]);
};

var label = false;
	
if (urlParams.has("label")){
	label = urlParams.get("label");
	//label = sanitize(label);
} 

var counter = 0;
worker.onmessage = function (e) { // // https://github.com/mozilla/translate - MPL 2.0 - Mozilla
    if (e.data[0] === "translate_reply" && e.data[1]) {
        document.getElementById("output").innerText = e.data[1].join("<br /><br />");
		counter+=1;
		if (label){
			socket.send(JSON.stringify({"msg":true, "final":e.data[1].join("\n\n"), "id":counter, "label":label, "c": document.getElementById("fullContext").checked, "ln": myLang}));
		} else {
			socket.send(JSON.stringify({"msg":true, "final":e.data[1].join("\n\n"), "id":counter, "c": document.getElementById("fullContext").checked, "ln": myLang}));
		}
    } else if (e.data[0] === "load_model_reply" && e.data[1]) {
        status(e.data[1]);
        //translateCall();
    } else if (e.data[0] === "import_reply" && e.data[1]) {
        modelRegistry = e.data[1];
        version = e.data[2];
        init();
    }
};

const isSupported = (lngFrom, lngTo) => {
    return true; //(`${lngFrom}${lngTo}` in modelRegistry) || ((`${lngFrom}en` in modelRegistry) && (`en${lngTo}` in modelRegistry))
}

const loadModel = () => { // // https://github.com/mozilla/translate - MPL 2.0 - Mozilla
    const lngFrom = langFrom.value;
    const lngTo = langTo.value;
    if (lngFrom !== lngTo) {
        if (!isSupported(lngFrom, lngTo)) {
            status("Language pair is not supported");
            document.getElementById("output").innerText = "";
            return;
        }

        status(`Installing model...`);
        console.log(`Loading model '${lngFrom}${lngTo}'`);
        worker.postMessage(["load_model", lngFrom, lngTo]);
    } else {
        const input = document.getElementById("input").value;
        document.getElementById("output").innerText = "";
    }
};

const findFirstSupportedTo = () => {
    return Object.entries(supportedToCodes).find(([code, ]) => code !== langFrom.value)[0]
}

langFrom.addEventListener("change", e => {  // // https://github.com/mozilla/translate - MPL 2.0 - Mozilla
    const setToCode = (currentTo !== langFrom.value)
      ? currentTo
      : findFirstSupportedTo();
	  
	myLangCode = langFrom.value.split("-")[0];
	if (myLangCode in supportedFromCodes) {
		console.log("guessing input language is", myLangCode);
		setFromCode = myLangCode;
	}
	recognition.stop(); // restarts with the new lang
    
    setLangs(langTo, supportedToCodes, setToCode, langFrom.value);
    loadModel();
});

langTo.addEventListener("change", e => {
    currentTo = langTo.value;
    loadModel();
});

const setLangs = (selector, langsToSet, value, exlcude) => {
    selector.innerHTML = "";
    for (const [code, type] of Object.entries(langsToSet)) {
        if (code === exlcude) continue;
        let name = langs[code];
        if (type === "dev") name += " (Beta)";
        selector.innerHTML += "<option value='"+code+"'>"+name+"</option>";
    }
    selector.value = value;
}

function init() {  // // https://github.com/mozilla/translate - MPL 2.0 - Mozilla
    // parse supported languages and model types (prod or dev)
    supportedFromCodes["en"] = "prod";
    supportedToCodes["en"] = "prod";
    for (const [langPair, value] of Object.entries(modelRegistry)) {
        const firstLang = langPair.substring(0, 2);
        const secondLang = langPair.substring(2, 4);
        if (firstLang !== "en") supportedFromCodes[firstLang] = value.model.modelType;
        if (secondLang !== "en") supportedToCodes[secondLang] = value.model.modelType;
    }

    // try to guess input language from user agent
    let setFromCode = "en";
    if (myLang) {
        myLangCode = myLang.split("-")[0];
        if (myLangCode in supportedFromCodes) {
            console.log("guessing input language is", myLangCode);
            setFromCode = myLangCode;
        }
    }
    setLangs(langFrom, supportedFromCodes, setFromCode, null);

    // find first output lang that *isn't* input language
    const setToCode = targetCode;
    setLangs(langTo, supportedToCodes, setToCode, setFromCode);
    currentTo = setToCode;

    // load this model
    loadModel();
}
	
	
	
function updateURL(param, force=false) {
	var para = param.split('='); 
	if (!(urlParams.has(para[0].toLowerCase()))){
		if (history.pushState){
			
			var arr = window.location.href.split('?');
			var newurl;
			if (arr.length > 1 && arr[1] !== '') {
				newurl = window.location.href + '&' +param;
			} else {
				newurl = window.location.href + '?' +param;
			}
			
			window.history.pushState({path:newurl},'',newurl);
		}
	} else if (force){
		if (history.pushState){
			var href = new URL(window.location.href);
			if (para.length==1){
				href.searchParams.set(para[0].toLowerCase(), "");
			} else {
				href.searchParams.set(para[0].toLowerCase(), para[1]);
			}
			log(href.toString());
			window.history.pushState({path:href.toString()},'',href.toString());
		}
	}
}

function generateStreamID(){
	var text = "";
	var possible = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789";
	for (var i = 0; i < 7; i++){
		text += possible.charAt(Math.floor(Math.random() * possible.length));
	}
	return text;
};

var roomID = "test";

if (urlParams.has("room")){
	roomID = urlParams.get("room");
} else if (urlParams.has("ROOM")){
	roomID = urlParams.get("ROOM");
} else {
	roomID = generateStreamID();
	updateURL("room="+roomID);
}


var url = document.URL.substr(0,document.URL.lastIndexOf('/'));

document.getElementById("shareLink").href= url+"/overlay?room="+roomID;
document.getElementById("shareLink").innerHTML = url+"/overlay?room="+roomID;

navigator.clipboard.writeText(url+"/overlay?room="+roomID).then(() => {
  /* clipboard successfully set */
}, () => {
  /* clipboard write failed */
});

var socket = new WebSocket("wss://api.caption.ninja:443");

socket.onclose = function (){
	setTimeout(function(){window.location.reload(true);},100);
};

socket.onopen = function (){
	socket.send(JSON.stringify({"join":roomID}));
}

var final_transcript = '';
var last_transcription  = "";
var second_transcription = "";
var idle = null;
var recognition = null;
setup();
var ends = 0;

function setup(){
	if ('webkitSpeechRecognition' in window){
		recognition = new webkitSpeechRecognition();
		if (myLang && myLangCode){
			if (myLang.split("-")[0] == myLangCode){
				recognition.lang = myLang;
			} else {
				recognition.lang = myLangCode;
			}
		} else if (myLangCode){
			recognition.lang = myLangCode;
		} else if (myLang){
			recognition.lang = myLang;
		}
		recognition.continuous = false;
		recognition.interimResults = false;
		
		recognition.onstart = function(){
			console.log("started transcription");
			setTimeout(function(){
				ends = 0;
			}, 2000);
			
		};
		recognition.onerror = function(event){
			console.error(event);
			
		};
		recognition.onend = function(e){
			console.log(e);
			console.log("Stopped transcription");
			
			if (event.type === "end"){
				ends +=1;
			}
			if (ends > 3){
				alert("WARNING: Cannot enable transcription service\n\nThe service will fail completely if more than one transcription session is currently active on your computer.\n\nPlease close other Caption.Ninja tabs or other transcription services and then wait a few minutes before retrying.");
			}
			setup();
		};
		recognition.onresult = function(event){
			counter+=1;
			var interim_transcript = '';
			if(typeof(event.results) == 'undefined'){
				console.log(event);
				return;
			}
			
			for(var i = event.resultIndex; i < event.results.length; ++i){
				if(event.results[i].isFinal){
					final_transcript += event.results[i][0].transcript;
				} 
			}
			
			if (final_transcript){
				console.log("FINAL:", final_transcript);
				document.getElementById("input").value = final_transcript;
				if (document.getElementById("fullContext").checked){
					translateCall(second_transcription + last_transcription +final_transcript);
				} else {
					translateCall(final_transcript);
				}
				second_transcription = last_transcription;
				last_transcription = final_transcript+". ";
				final_transcript = "";
			} 
			
		};
		
		//recognition.lang = 'en-US';
		recognition.start();
	}
}
</script>
	</body>
</html>
